---
layout:     post
title:      "java基础之静态,构造代码块"
subtitle:   "各种代码块,和构造方法详解"
date:       2018-07-31 12:00:00
author:     "Chamber"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - java
    - Java基础
    - 静态方法
    - 数据类型
---
# 成员变量

## 特点

1. 在创建对象的时候被赋予默认值
2. 可以在类中定义变量的时候直接赋值
3. 在可以没有被static修饰的方法以外直接使用

- 比较成员变量和局部变量?

1. 作用域:成员变量是很整个对象,局部变量是从定义开始到所在函数/if/for结束
2. 默认值:成员变量会有默认值,局部变量没有默认值,要想使用必须先赋值
3. 释放机制:成员变量跟对象保持一致,通过垃圾回收机制回收,局部变量使用完立即释放
4. 存放的位置:成员变量放在堆区中的对象中,局部变量放在栈区中的方法中.


# 静态static

> 成员变量可以分为两类:静态的(被static修饰)和非静态的

静态的: 有静态方法和变量
> 可以通过引用调用又可以通过类名调用,推荐使用类名调用

非静态:非静态的方法和属性
> 只能通过引用调用

<font color="red">优先使用静态方法 </font>

#### - 注意

###### 执行顺序优先级：静态块>main()>构造块>构造方法

代码解释

```
public class B
{
    public static B t1 = new B();
    public static B t2 = new B();
    {
        System.out.println("构造块");
    }
    static
    {
        System.out.println("静态块");
    }
    public static void main(String[] args)
    {
        B t = new B();
    }
}

```

###### 静态的成员变量是被所有人共用的

## Q&A

##### Q:被static修饰的成员变量的提点
A:
1. 被当前类的所有对象共享
2. 由随着对象的加载编程随着类的加载而加载,变量被放在了静态方法区,执行顺序优先于否静态的成员变量
3. 可以使用类名或引用调用
4. 

##### Q: 静态的成员变量与非静态的成员变量的区别:
A:
1. 存储的数据的使用:非静态的只能供当前的兑现更实用,静态的供所有对象共享
2. 生命周期:非静态的跟对象一直,静态的跟程序一致
3. 存储的位置:非静态的:对象中 ---  静态的:静态方法区
4. 访问的方式:非静态的:引用 ---- 静态的:引用或类名


##### Q: 被static修饰的成员方法的特点
A:
1. 静态的成员方法内部职能使用静态的成员变量
2. 非静态的内部既可以使用静态的成员变量,也可以使用非静态的成员变量




# 构造方法

> 调用的时候的方法

构成```类名+()```

作用:对对象的属性进行初始化,如果我们不自己创建构造方法,系统会调用默认的无参构造方法

定义时的基本构成
```
修饰词 方法名(参数列表){
    方法体
}
```

### 无参的构造方法

> 会讲成员变量初始化成null或0或false等

### 有参的构造方法

> 会讲成员变量进行初始化并赋值(赋值成通过参数传入的值)

###### -注意点
1. 没有返回值这一项
2. 方法名必须和当前的类名相同


###### -使用构造方法的注意点:
1. 一旦创建了自己的构造方法,就不会再去调用系统默认的构造方法
2. 多个构造方法之间是重载的关系

### this
> this是一个关键字,是一种引用数据类型,代表的是当前的对象,保存的是当前对象的地址

- 使用场景:
想在当前类的内部拿到当前对象的引用的时候使用this

##### Q:this的作用?
A:
1. 区分成员变量和局部变量
2. 可以在构造方法中调用其他重载的构造方法,提高代码的复用性,简化代码.

##### Q:关于this的注意点?
A:
1. 在作为方法的时候,只适用于构造方法
2. 不能自己调用自己--死循环
3. 不能相互调用--死循环
4. 在构造方法中调用其他的重载的构造方法,必须在方法第一行
5. 在静态方法中无法使用this



```
//无参构造方法
public Student(){
    //在构造方法的内部会自动的进行属性的初始化.
}

//有参的构造方法
//当成员变量与形参名字的名字一致时,方法内部识别的是形参,一局的是就近原则
//就近原则是从内存的角度考虑远近
public Student(String name){
    //一般有参的构造方法是给属性赋值
    this.name = name;//给对象的属性完成赋值
}
public Student(String name,int age){
    //通过this调用其他构造方法的时候必须放在方法的第一行
    this(name);
    this.age = age;
}
public Student(String name,int age ,String gender){
    this(name,age);
    this.gender = gender;
}

```
# 静态代码块
> 随着类的加载而加载,在整个程序执行的过程中只执行一次,执行顺序优先于main

- 做类的初始化工作

构成:static+{代码}
```
static {
    
}
```

# 构造代码块

> 随着对象的加载而加载,每次创建对象都会执行一次,执行顺序优先于构造方法

- 做对象的初始化工作

```
{
    
}
```


<font color="red">误区重获:</font>

1. 面向对象中的方法,最好传入对象,而不是对象的属性.在方法内再进行提取数据

