---
layout:     post
title:      "java基础之反射"
subtitle:   "反射"
date:       2018-08-24 12:00:00
author:     "Chamber"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - java
    - 反射
    - Java基础
    - 数据类型
---
# 反射

> 动态获取类的字节码文件对象,并对其成员进行抽象

反射的过程如下:

## 1.获取字节码文件对象

获取的流程                           
1. 通过object提供的方法,getClass(),得到字节码文件对象        
**缺点:** 必须首先要有一个对象       不可取

1. 每种数据类型都有一个class属性,通过他可以的到字节码文件对象          
**缺点:** 必须要先知道有这个类的名字,    也不可取 

1. Class类提供的静态方法,forName(字符串)   字符串的构成:包名+类名 
**优点:** 只需要提供一个你需要的类的字符串形式
                                            
**注意点:** 字符串必须对应于一个真实存在的类,否则报异常ClassNotFoundExcpt
               
```
//a:通过object提供的方法,getClass()
//说明一个类只有一个字节码文件对象
public static void fun1() {
	Person person = new Person();
	Class<?> class1 = person.getClass();//字节码文件
	Class<?> class2 = person.getClass();
	System.out.println(class1==class2);
}

//b:每种数据类型都有一个class属性,通过他可以的到字节码文件对象 
public static void fun2() {
	Class<?> class1 = Person.class;
	System.out.println(class1);
}

//c:Class类提供的静态方法,forName(字符串)   字符串的构成:包名+类名
public static void fun3() throws ClassNotFoundException {
	Class class1 = Class.forName("com.qianfeng.fanshe.Person");
	System.out.println(class1);
}
```
                             
**对c做一个总结:** 沟通过字符串可以知道到工程中实际存在的类                

## 2. 通过字节码对象获取对应的实例对象    

```
//通过无参的构造方法创建对象
public static void fun1(Class<?> class1) throws InstantiationException, IllegalAccessException {
	//创建实例对象
	//相当于在newInstance方法的内部调用了无参构造方法
	Object object = class1.newInstance();
	
	Person person = (Person) object;
	person.setName("孙燕姿");
	System.out.println(person.getName());
}
//通过有参的构造方法创建对象
public static void fun2(Class<?> class1) throws NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
	//得到有参的构造方法
	//这里的参数时实际的构造方法的参数的字节码文件
	//注意点:简单数据类型也有字节码文件,获取字节码文件的方式都可以通过.class实现
	Constructor<?> constructor = class1.getConstructor(String.class);
	
	//调用构造方法
	Object object = constructor.newInstance("孙燕姿");//给的是实际的值
//		Person person = (Person) object;
	System.out.println(object);
}
```

## 3.给属性赋值(通过从属性中提取出来的类--field

```
public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, SecurityException, InstantiationException, IllegalAccessException {
	//通过普通的方法
	Person person = new Person();
	person.setName("孙燕姿");
	
	//通过反射实现--通过字节码文件创建对象调用
	//1.得到字节码文件
	Class class1 = Class.forName("com.qianfeng.fanshe.Person");
	
	//2.调用Filed相关方法得到属性
//		Field field = class1.getField("name");
	
	//忽略权限
	Field field = class1.getDeclaredField("name");
	
	//解释:当属性时私有的,我们要通过反射进行访问,可以做的方法:
	//首先使用getDeclaredField(),然后再调用setAccessible(),并将参数设为true
	field.setAccessible(true);
			
	//3.通过字节码文件创建Person类型的实例对象
	Object per = class1.newInstance();
	
	//4.将field属性指定给当前的实例对象,并完成赋值
	//第一个参数:绑定的具体的实例对象
	//第二个参数:给他赋的值
	field.set(per, "孙燕姿");//等价于per.name="孙燕姿";
	
	System.out.println(field.get(per));
	
	//通过字节码文件再创建一个对象
	Object per1 = class1.newInstance();
	field.set(per, "孙");
	System.out.println(field.get(per));
	
}
```

## 4.调用方法(通过从方法中提取出来的类--Method) 

```
// 1.调用非静态的无参方法
public static void fun1(Class<?> class1) throws NoSuchMethodException, SecurityException, InstantiationException,
		IllegalAccessException, IllegalArgumentException, InvocationTargetException {
	// 第一个参数是创建的方法的方法名 第二个:实例方法参数的字节码文件对象
	Method method = class1.getMethod("run");

	// 创建实例对象
	Constructor<?> constructor = class1.getConstructor(String.class);
	Object per = constructor.newInstance("bingbing");

	// 实现方法的调用
	// 第一个参数:方法所属的对象
	// 第二个:方法的参数
	method.invoke(per);
}

// 2.调用非静态的有参方法
public static void fun2(Class<?> class1) throws NoSuchMethodException, SecurityException, InstantiationException,
		IllegalAccessException, IllegalArgumentException, InvocationTargetException {
	// 第一个参数是创建的方法的方法名 第二个:实例方法参数的字节码文件对象
	Method method = class1.getMethod("eat", String.class);

	// 创建实例对象
	Constructor<?> constructor = class1.getConstructor(String.class);
	Object per = constructor.newInstance("bingbing");

	// 实现方法的调用
	// 第一个参数:方法所属的对象
	// 第二个:方法的参数
	method.invoke(per, "apple");

}

// 3.调用静态的的有参方法
public static void fun3(Class<?> class1) throws NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
	// 第一个参数是创建的方法的方法名 第二个:实例方法参数的字节码文件对象
	Method method = class1.getMethod("play", int.class);

	// 实现方法的调用
	// 第一个参数:方法所属的对象
	// 第二个:方法的参数
	method.invoke(null,30);
}
```

# 实例

过反射可以在不改变功能类(Demo)的前提下,实现新增功能的添加,我们只需要创建对应的工具类,(UPan,Mouse). 再通过一个配置文件简单的配置即可

```
//利用反射实现在不改变当前类的代码的前提下,实现新增功能的添加
//读取config.properties的内容
Properties properties = new Properties();

//创建字符输入流
FileInputStream fileInputStream = new FileInputStream("src/com/qianfeng/fansheDemo/cofig.properties");

//将数据加载到properties对象内部
properties.load(fileInputStream);

//properties.size():获取的是键值对的个数
for (int i = 0; i < properties.size(); i++) {
	String key = "usb"+i;
	String value = properties.getProperty(key);
	
	//获取字节码问价对象
	Class<?> class1 = Class.forName(value);
	
	//创建实力对象
	USB usb =(USB) class1.newInstance();
	usb.open();
	usb.close();
}
```

cofig.properties
```
usb0=com.qianfeng.fansheDemo.Mouse
usb1=com.qianfeng.fansheDemo.KeyBoard
usb2=com.qianfeng.fansheDemo.UPan
```

只需要在配置文件中修改类的内容即可