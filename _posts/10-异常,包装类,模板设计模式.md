---
layout:     post
title:      "java基础之异常,包装类,模板设计模式"
subtitle:   "java基础之异常,包装类,模板设计模式"
date:       2018-08-06 12:00:00
author:     "Chamber"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - java
    - Java设计模式
    - Java基础
    - 异常处理
    - 数据类型
---
# 异常

- 异常的特点:

当程序出现异常的时候,程序会打印异常信息并中断.<br>
所以,当同时多个异常的时候,只能执行第一个.

### 数组下标越界异常

```
int[] arr = new int[]{4,5,6};
System.out.println(arr[7]);
```

### 空指针异常

```
int[] arr = null;
System.out.println(arr[0]);
```

# 异常处理

> 对异常的处理

```
try{
    可能出现异常的代码
}catch(Exception e){
    e.printStackTrace();//可以打印异常的位置,原因,名字等信息

    对出现异常的代码的处理过程
}catch(多个异常可以多次捕获){
    
}finally{
    必须执行的代码(不论异常出现了什么错误都可以执行到这里.但是退出程序后finally不会执行)
    作用:
    用于资源的释放:比如:多线程中的锁对象,流的关闭,数据库的关闭
}
```

##### e.toString()
> 得到异常的名字,原因
##### e.getMessage()
> 得到异常的原因

###### 注意:
- 在catch中Exception 异常一定要放在最后一个
- 登记越低越靠前


# finally

> try finally 结构

```
try{
    获取资源
}finally{
    释放资源
}

```

# 自定义异常

> 自己定义的异常类,由于Exception里面有异常的基本功能,一般我们都写 Exception的子类

- 为什么要有自定义异常<br>
答:    系统没有定义的异常需要我们自己定义,我们解决的是系统没有解决的问题.

- 异常的分类:<br>
1. 编译时异常:在编译阶段抛出,处理的异常---除RunTimeException意以外的所有异常(所有相关的工作都要有我们自己完成)
2. 运行时异常:在运行时抛出,处理的异常--RunTimeException异常(所有的工作我们都可以不管)

- 让谁去处理比较合适?<br>
谁调用抛出异常的方法谁就去处理异常
```
public class Demo2 {
	public static void main(String[] args) {
		Math math = new Math();
		try {
			math.div(3,-2);
		} catch (CustomException e) {
			e.printStackTrace();
		}
	}
}
class Math{
	//声明异常.告诉别人,我有可能发生异常
	public int div(int a,int b) throws CustomException {
		if (b<0) {
			throw new CustomException();//手动生成并抛出除数为负数的异常
		}
		return a/b;
	}
}
/**
 * 构造一个除数为负数的异常
 */
class CustomException extends Exception{
    public CustomException(){
        
    }
    public CustomException(String message){
        
    }
}
```
###### 在重写的方法中使用异常的注意点:
1. 子类的同名方法中声明的异常等级要=<父类的
2. 子类的同名方法中声明的异常可以与父类的不一致,也可以不声明异常.但是此时子类方法不能再抛出异常
3. 如果子类同名方法声明了异常,父类必须声明异常.


# 包装类

> 专门将简单数据类型的数据进行封装.形成了对应的类

简单数据类型 | 包装类
:- | :-
byte | Byte
short | Short
int | Integer
long | Long
float | Float
double | Double
boolean | Boolean
char | Character

- 作用:
1. 可以方便实现简单数据类型和字符串时间的转换
2. 便于在集合中存储
3. 可以更加便捷的对简单数据类型进行操作

#### 基本类型转成字符串类型
```
    static String Integer.toString(int i)
    static String Double.toString(double d)
```
#### 字符串类型转基本类型
```
    int     Integer.parseInt("23")
	double  Double.parseDouble("3.45")
```

- 如果出现非数字的类型,会报异常

#### 把十进制转成其它进制
```
   Integer.toHexString()
   Integer.toOctalString()
   Integer.toBinaryString()
```
#### 把其它进制转十进制
```
Integer.parseInt(数据,进制)
 ```
 

#### 拆箱
> 从包装类中取出简单数据类型的过程

```
// 装箱
		int temp = 1000;
		Integer integer = new Integer(temp);
```

#### 装箱
> 将简单数据类型使用包装类对象进行封装

```
// 拆箱
		int temp1 = integer.intValue();
		System.out.println(temp1);
```

- 从jdk1.5开始实现了自动装拆箱

```
Integer integer2 = new Integer(4);
Integer integer3 = integer2 + 3;//先将integer2进行了自动拆箱得到4,用4和3完成计算得到了7,再将7自动装箱
System.out.println(integer3);//--->7  重写了toString()方法
```

###### 注意:
> 在一个字节范围内前面定义好的,后面在定义,直接使用前面的

> 如果超出了一个字节的范围,被认为是两个数,要独立占用两块空间

```
Integer integer4 = 100;
Integer integer5 = 100;
System.out.println(integer4 == integer5);
//--->true

integer4 = 10000;
integer5 = 10000;
System.out.println(integer4 == integer5);
//--->false
```

# 模板设计模式

> 实现一个功能的时候,分成两部分,将确定的部分由当前类实现,不确定的部分交给子类实现,子类实现的结果又会反过来影响确定的部分.

```
/**
 * 实例:求一个程勋运行的时间
 * 分析:1.知道开始的时间
 * 2.运行的时间
 * 3.结束的时间
 * @author 弄风
 *
 */
public class Demo6 {
	public static void main(String[] args) {
		Zi zi = new Zi();
		double time = zi.getTime();
		System.out.println(time);
	}
}
abstract class Fu{
	public abstract void function();
	public double getTime() {
		long startTime = System.nanoTime();//获取的当前系统时间,单位:纳秒  1秒 = 0.000000001秒
		
		function();
		
		long endTime = System.nanoTime();
		return endTime - startTime;
	}
}
class Zi extends Fu{
	public void function() {
		for (int i = 0; i < 100; i++) {
			System.out.println(i);
		}
	}
	
}
```


