---
layout:     post
title:      "java基础之抽象类,多态"
subtitle:   "java基础之抽象类,多态"
date:       2018-08-02 12:00:00
author:     "Chamber"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - java
    - Java基础
    - 多态
    - 数据类型
---
# abstract

> 抽象的

- 可以修饰:类和方法

### 抽象类

> 在继承中,提取父类方法的时候,每个子类都必须有自己的实现方法,父类不能界定他们各自的实现方法.父类只需要写方法的声明即可.将方法的实现交给子类,在类中只有方法声明的方法称为抽象方法,拥有抽象方法的称为抽象类

- 相当于制定了一个规则,让子类去完成

###### 注意:
1. 抽象类不一定有抽象方法,但是有抽象方法的一定是抽象类.
2. 继承了抽象类的子类一定要实现抽象方法,如果不实现就只能将自己也变成抽象的.
3. 抽象类不能直接创建对象,必须通过子类实现,所以抽象类一定有子类

###### Q&A
- Q:比较普通类与抽象类
- A:
1.  普通类可以直接创建对象
1.  抽象类可以有抽象方法 

- Q:不能与abstract同时存在的关键字
- A:
1. final:被final修饰的类不能有子类,方法不能重写,但是abstract必须有子类,必须重写
2. static:修饰的方法可以通过类名调用,abstract必须通过子类实现
3. private:修饰的方法不能重写,abstract必须重写

```
abstract class A{//抽象类,拥有抽象方法的一定是抽象类
    public abstract void a();//抽象方法
}
class B extends A{
    public void a(){//此方法必须有
        
    }
}
//或
//可以将子类变成抽象类,但之后想要使用当前得嘞就必须再创建子类,因为抽象类不能直接创建对象
abstract class C extends A{
    //抽象类可以不写a()抽象方法
    //此方法在此类中还是凑向方法,不能够调用
}
public class main{
    public static void main(String[] args){
        //抽象类不能直接创建对象,必须通过子类实现功能
        A a = new A();//此语句为错误的
    }
}
```

# interface

> 一般接口中不写成员变量,只写方法--只写规则,又将接口称为方法列表

- 起作用的方式:让类去实现接口

1. 类与类之前的关系:继承--extends
2. 类与接口之间的关系:实现--implements

构成:
```
interface 接口的名字{
    //接口的实现部分
    成员变量;//默认是public final static
    成员方法;//默认是public abstract
}
```
实现:
```
//接口本身是抽象的
interface Inter1{
	int age = 4;//默认是public final static的,所以定义的时候必须给赋一个值
	public void show();//默认是abstract的,
}

class Son implements Inter1{
	//重写show()方法
	public void show() {
		
	}
}
```

# 多态

> 一种事物的多种形态

- 多态的前提:类与类之间必须有继承的关系


- 用父类的引用指向子类的对象--这就是java中多态在代码中的具体体现

###### 程序运行分成三个阶段
1. 预编译:程序打开的时候,活儿已经干完了.(预处理命令)
2. 编译:从打开程序开始到点击Run之前.整个过程都是编译阶段.只能识别=前面的引用类型,不会识别后面的对象
3. 运行:从点击Run开始---真正的识别对象,对象开始干活.

###### 缺点:
只能直接调用父类有的方法,不能直接调用子类特有的方法
###### 优点:
可以提高代码的扩展性,使用之前定义好的功能,不用再创建新的方法
```
//注意:这里所说的父类可以是直接的父类也可以是间接的父类
Animal animal = new Dog();

animal.play();//父类中的方法
animal.show();//子类中的方法,此语句错误
//错误的原因:在编译的时候识别的是引用类型,不识别对象,所以只能识别出Animal里面的方法,而不能直接调用子类特有的方法
```

###### 了解的内容
实现动态的手段:冬天类型,动态绑定,动态加载
动态加载:我们在编译过程不能确定具体的对象类型,只有到了运行阶段才能确定真正干活的对象

## 向上转型

> 相当于自动类型转换,由低类型到高类型

- 定义:

将子类的引用转换成父类的引用,注意:只是将引用进行转换,与=后面的对象无关

```
//向上转型
Animal dog = new Dog();
```

## 向下转型

> 相当于强制类型转换,由高类型到低类型

- 定义

将父类的引用强制转换成子类的引用.

```
//向下转型
Dog dog = (Dog) dog;
dog.show();//调用子类特有的方法
```
##### 注意:
```
//1.这里不叫向上转型,不能视图用子类的引用执行父类的对象
Dog dog = new Animal()//这是错误的
```
```
//2这里不是向下转型,向下转型的前提是多态
Animal animal = new Animal();//这里不是多态
Dog dog = (Dog1)animal;
```

## instanceof

```
//容错处理--增加用户体验
if (animal1 instanceof Dog) {
	Dog dog = (Dog)animal1;
	dog.bark();
}
```

- 定义:

确定前面的对象是否是后面的类或子类的对象,是返回true,不是返回false

- 前提:

前面和后面必须有继承的关系

# 多态运行时的顺序

```
package demo;

public class Demo5 {
	public static void main(String[] args) {
		
		//多态体系下
		/*
		 * 当父类与子类定义了同名的属性
		 * 成员变量:编译的时候能不能访问看父类,运行的时候也看父类
		 * 成员方法:编译的时候看父类,运行的时候看子类
		 * 静态成员方法:编译运行都看父类
		 */
		
		Fu a = new Zi();
		System.out.println(a.age); //5
		a.song();	//Zi-song
		a.run();	//Zi-run
	}
}
class Fu{
	int age = 5;
	public void run() {
		System.out.println("Fu-run");
	}
	public void song() {
		System.out.println("Fu-song");
	}
}
class Zi extends Fu{
	int age = 8;
	public void run() {
		System.out.println("Zi-run");
	}
	public void song() {
		System.out.println("Zi-song");
	}
	public void play() {
		System.out.println("Zi-play");
	}
}
```
