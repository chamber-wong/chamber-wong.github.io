---
layout:     post
title:      "java基础之封装,重写,单例"
subtitle:   "java基本特性,封装重写,和单例设计模式"
date:       2018-08-01 12:00:00
author:     "Chamber"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - java
    - Java基础
    - 单例
    - 数据类型
---
# 封装性

> (根据对属性的封装来说明)吧对成员变量进行私有化,通过一个公共的方法间接的实现了访问.

- 优点:
1. 提高了代码的安全性,提高了代码的可读性和复用性


###### 脏数据

- 在程序中出现不符合逻辑的数据称为脏数据
- 通过对数据的封装可以实现对脏数据的处理


# getter和setter方法

#### set

> 指的是赋值的过程

构成 
```
修饰词 返回值类型 方法名(参数类表){
    方法体;
    返回值
}

//返回值类型: 不需要--void
//方法名:set+成员变量的名字,但是成员变量的首字母需要大写
//参数列表:一个方法完成对一个属性的赋值,所以只需要一个参数.参数的类型与成员变量一直,参数的名字与成员变量一致
```

#### get

> 取值的过程

构成
```
修饰词 返回值类型 方法名(参数类表){
    方法体;
    返回值
}
//返回值类型: 类型与成员变量一致
//方法名:get+成员变量的名字,但是成员变量的首字母需要大写
//参数列表:不需要参数
//方法体:return成员变量
```

# 继承

> 定义:有两个类:A类与B类,当两个类之间产生父子关系的时候,我们称为继承

- 功能:

简化代码,方便操作,提高代码的复用性,提高了安全性,增加了代码的健壮性,使类与类之间产生了集成的关系,是多态的前提

- 注意点:

父类中被private修饰的成员子类不能使用,但是在子类中式可见的.

```
class Phone{
	String color;
	int model;
	public void callPhone() {
		System.out.println("打电话");
	}
	
}
//创建iphone类
class IPhone extends Phone{
	String gui;
	public void fangshui() {
		System.out.println("防水");
	}
}
//创建华为类
class HUAWEI extends Phone{
	public void nv() {
		System.out.println("牛逼");
	}
}
```

###### 原理
- 首先由引用找到当前的子类对象,在当前的对象里找到这个方法,找到了,直接调用,如果没有,再去父类中找,找到了调用,找不到再继续向上找,一直找到Object,如果还是没有找到,说明没有这个方法


# 重写

> 当子类有与父类同名(方法名,参数等完全相同),我们称为重写 

###### 注意点:
1. 相当于子类的同名方法将父类的覆盖了,不会再去调用父类的方法.
2. 私有方法不能被重写
3. 子类的同名方法的权限大于等于父类的同名方法
4. 静态的方法只能覆盖静态的方法

###### 作用:
在不改变父类方法名字的前提下,在父类原有方法的功能基础,实现一些自己的功能.实现了对原有功能的扩充.
```
class Animal{
	public Animal() {
		// TODO Auto-generated constructor stub
	}
	public Animal(String name) {
	}
	private String name;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
}
class Dog extends Animal{
	public Dog() {
		super();//必须放在第一行76--
		// TODO Auto-generated constructor stub
	}
	public Dog(String name) {
		super(name);
		// TODO Auto-generated constructor stub
	}
	public void play() {
		System.out.println("play");
	}
}

```
# super关键字

```
class Phone{
	String color;
	int model;
	public void callPhone() {
		System.out.println("打电话");
	}
	
}
//创建iphone类
class IPhone extends Phone{
	String gui;
	public void callPhone() {
	    //this.callPhone;//调到的是本对象的callPhone方法---死循环
		super.callPhone();//直接调用的是父类的方法
		
		System.out.println("有自己特有的功能!");
	}
}
```
# 在继承中使用构造方法

1. 当一个子类中只有一个带有参数的构造方法,只能使用带参数的,不能使用无参的,如果想使用,必须手动建立无参的构造方法
2. 当父类中只有带参数的构造方法,子类的构造方法中就必须在第一行手动调用父类带参数的构造方法(super(参数))
3. 当我们创造构造方法的时候,如果自己不写super(),系统会自动调用
-原因:
父类中也有属性要进行初始化,而对象的属性必须由自己的构造方法进行初始化,所以必须调用super(),所以每个构造方法中都有一个super()

# Q&A

###### Q:this和super的比较:
A :

this是一种引用数据类型,代表当前的对象,保存吧的是当前对象的地址<br>
super:不是一种引用数据类型,可以通过super调用父类的成员.

# 设计模式

> 前人总结出来的经验,被后人拿来直接使用

- 常用的设计模式:
有23种,我们要学的有单例,模板,装饰,适配器,工厂,代理等

# 单例设计模式

> 一个类只允许有一个对象,将这个对象作为一个全局的访问点,提供出来供大家使用 

- 分析
1. 只能有一个对象
2. 全局的访问点:得到的对象就是全局的访问点,如何做到全局?让static去修饰只想对象的变量
3. 如何提供出去?
4. 供大家使用?--单例的功能


实例
```
package demo;

public class Demo5 {
	public static void main(String[] args) {
		SingleInstance sInstance  = SingleInstance.getSingleInstance();
		SingleInstance sInstance1  = SingleInstance.getSingleInstance();
		System.out.println(sInstance == sInstance1);
	}
}
/**
 * 单例模式
 * 恶汉式-在定义变量的同时完成初始化
 * @author 弄风
 *
 */
class SingleInstance{
	//在类的内部创建一个当前类型的属性并赋值--在类的内部得到了当前类的一个对象
	//将变量私有化,让外界无法直接访问  给变量用static修饰让它成为全局的访问点
	private static final SingleInstance singleInstance = new SingleInstance();
	
	//将构造方法私有化
	private SingleInstance() {
		
	}
	//使用公共的方法将变量提供出去,并将方法设置成静态的
	public static SingleInstance getSingleInstance() {
		return singleInstance;
	}
}
/**
 * 单例模式
 * 懒汉式-开始只是定义变量,什么时候使用什么时候赋值
 * @author 弄风
 *
 */
class SingleInstance1{
	//在类的内部创建一个当前类型的属性并赋值--在类的内部得到了当前类的一个对象
	//将变量私有化,让外界无法直接访问  给变量用static修饰让它成为全局的访问点
	private static SingleInstance1 singleInstance = null;
	
	//将构造方法私有化
	private SingleInstance1() {
		
	}
	//使用公共的方法将变量提供出去,并将方法设置成静态的
	public static SingleInstance1 getSingleInstance() {
		if (singleInstance == null) {
			singleInstance = new SingleInstance1();
		}
		return singleInstance;
	}
}
```

# final

> 最终的不可改变的.

- 可以修饰的:
1. 类:类不能创建子类
2. 成员方法:方法不能够重写
3. 成员变量:变量的值就变成了一个终值,也就是常量,所以被final修饰的变量必须先给一个值.
4. 局部变量:同成员变量