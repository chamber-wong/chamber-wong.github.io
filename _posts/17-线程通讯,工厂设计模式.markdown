---
layout:     post
title:      "java基础之TCP通讯"
subtitle:   "线程通讯,工程设计模式"
date:       2018-08-15 12:00:00
author:     "Chamber"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - java
    - 设计模式
    - TCP
    - Java基础
    - 数据类型
---
# 线程间的通讯

- 不考虑交替执行

```
package com.qianfeng.test;
/*
 * 两个线程的通信:
 * 实例:打印机打印--不断的输入不断的输出
 * 分析:
 * 两个线程:输入线程,输出线程
 * 两个任务:输入任务,输出任务
 * 一份数据
 */
public class Demo2 {
	public static void main(String[] args) {
		//0.创建数据类对象
		Des des = new Des();
		
		//1.创建任务
		Input input = new Input(des);
		Output output = new Output(des);
		
		//2.将任务交给线程
		Thread inputThread = new Thread(input);
		Thread outputThread = new Thread(output);
		
		//3.开启线程
		inputThread.start();
		outputThread.start();
	}
}

//创建数据类
class Des{
	String name;
	String sex;
}

//创建输入任务
class Input implements Runnable{
	Des des;
	public Input(Des des) {
		super();
		this.des = des;
	}
	public void run() {
		/*
		 * 需要给输入任务和输出任务同时加一把锁,保证两个任务之间是同步的
		 * 给两个任务加一把锁:可以是des或者Object.class
		 * 分析:
		 * 不建议使用Object.class:由于Object的使用范围太大,可能造成不必要的错误.
		 * 使用des最合适,因为他只被当前的两个任务共享.
		 * 
		 *注意:对于当前的情况只给一个线程加锁,无法实现两个线程的同步.
		 */
		int i=0;
		while (true) {
			synchronized (des) {
				if (i==1) {
					des.name = "特没谱";
					des.sex = "男";
				}else {
					des.name = "安倍小三";
					des.sex = "女";
				}
				
				i = (i+1)%2;
			}
		}
	}
}
//输出任务
class Output implements Runnable{
	Des des;
	public Output(Des des) {
		super();
		this.des = des;
	}
	public void run() {
		while (true) {
			synchronized (des) {
			    System.out.println("姓名:"+des.name+"    性别:"+des.sex);
			}
		}
	}
}

```

- 考虑交替执行

```
package com.qianfeng.test;
/*
 * 两个线程的通信:
 * 实例:打印机打印--不断的输入不断的输出
 * 分析:
 * 两个线程:输入线程,输出线程
 * 两个任务:输入任务,输出任务
 * 一份数据
 * 
 * 
*继续实现一次打印一次输出
 *使用唤醒等待机制---notify()/notifyAll()/wait()
 *wait():让当前的线程变成等待的状态,放入一个池子(线程池),失去了抢cpu的能力,.等待唤醒(锁相当于给当前的线程做了一个标记)
 *
 *notify():让当前的线程从等待状态唤醒,相当于从池子中取出线程.(唤醒的是同一把锁下的任意一个线程)
 *
 *notifyAll():唤醒的是同一把锁下的所有线程
 **/
public class Demo3 {
	public static void main(String[] args) {
		//0.创建数据类对象
		Des1 des = new Des1();
		
		//1.创建任务
		Input1 input = new Input1(des);
		Output1 output = new Output1(des);
		
		//2.将任务交给线程
		Thread inputThread = new Thread(input);
		Thread outputThread = new Thread(output);
		
		//3.开启线程
		inputThread.start();
		outputThread.start();
	}
}

//创建数据类
class Des1{
	String name;
	String sex;
	
	boolean flag=false;//创建一个标识,控制等待与唤醒之间的切换
	
	/*
	 * 需要给输入任务和输出任务同时加一把锁,保证两个任务之间是同步的
	 * 给两个任务加一把锁:可以是des或者Object.class
	 * 分析:
	 * 不建议使用Object.class:由于Object的使用范围太大,可能造成不必要的错误.
	 * 使用des最合适,因为他只被当前的两个任务共享.
	 * 
	 *注意:对于当前的情况只给一个线程加锁,无法实现两个线程的同步.
	 */
	//处理输入
	public synchronized void setData(String name,String sex){
		if (flag == true) {//当 flag值为true的时候,让输入线程处于等待状态
			try {
				//在执行代码的时候,这里对应的是哪个线程,锁对象操作的就是哪个线程.
				wait();
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		this.name = name;
		this.sex = sex;
		//将表示改成true
		flag = !flag;
		//将输出线程唤醒
		//在唤醒的时候,在线程池中没有找到当前锁标记的线程.我们称为空唤醒,程序允许空唤醒.
		notify();
	}
	
	//处理输出
	public synchronized void getData(){
		if (flag == false) {//当 flag值为false的时候,让输出线程处于等待状态
			try {
				wait();
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		System.out.println("姓名:"+name+"    性别:"+sex);
		
		flag = !flag;
		
		notify();//唤醒的输入线程
	}
}

//创建输入任务
class Input1 implements Runnable{
	Des1 des;
	public Input1(Des1 des) {
		super();
		this.des = des;
	}
	public void run() {
		int i=0;
		while (true) {
			if (i==1) {
				des.setData("特没谱", "男");
			}else {
				des.setData("安倍小三", "女");
			}
			
			i = (i+1)%2;
		}
	}
}
//输出任务
class Output1 implements Runnable{
	Des1 des;
	public Output1(Des1 des) {
		super();
		this.des = des;
	}
	public void run() {
		while (true) {
			 des.getData();
		}
	}
}
```

# 单生产者,单消费者模式

```
package com.qianfeng.test;
/*
 * 生产者消费者
 * 分类:
 * 单生产者单消费者
 * 多生产者的消费者
 * 
 * 
 * 单生产者单消费者:
 * 两个线程:生产线程,消费线程
 * 两个任务:生产任务,消费任务
 * 一份数据
 */
public class Demo4 {
	public static void main(String[] args) {
		//1.准备数据
		Product product = new Product();
		//2.创建生产消费任务
		Producer producer = new Producer(product);
		Consumer consumer = new Consumer(product);
		//3.创建生产消费线程
		Thread thread1 = new Thread(producer);
		Thread thread2 = new Thread(consumer);
		//4.开启线程
		thread1.start();
		thread2.start();
	}
}

//数据类
class Product{
	String name;
	double price;
	int count;
	
	//标识
	boolean flag;
	
	//准备生产
	public synchronized void setProduce(String name,double price) {
		if (flag == true) {
			try {
				wait();
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		
		this.name = name;
		this.price = price;
		
		System.out.println(Thread.currentThread().getName()+"  生产了:"+name+"  产品的数量:"+count+"  产品的价格:"+price);
		
		count++;
		
		flag = !flag;
		
		//唤醒消费线程
		notify();
	}
	//准备消费
	public synchronized void consume() {
		if (flag == false) {
			try {
				wait();
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		
		System.out.println(Thread.currentThread().getName()+"  消费了:"+name+"  产品的数量:"+count+"  产品的价格:"+price);
		
		flag = !flag;
		
		//唤醒生产线程
		notify();
	}
}
//生产任务
class Producer implements Runnable{
	Product product;

	public Producer(Product product) {
		super();
		this.product = product;
	}
	
	public void run() {
		while (true) {
			product.setProduce("bingbing", 10);
		}
	}
}
//消费任务

class Consumer implements Runnable{
	Product product;

	public Consumer(Product product) {
		super();
		this.product = product;
	}
	
	public void run() {
		while (true) {
			product.consume();
		}
	}
}

```
# 多生产者,多消费者模式

> 使用synchronized和object的wait,notifyAll方法

```
package com.qianfeng.test;
/*
 * 生产者消费者
 * 分类:
 * 单生产者单消费者----会
 * 多生产者多消费者----了解
 * 
 * 
 * 多生产者多消费者:
 * 两个生产线程,两个消费线程
 * 两个任务:生产任务,消费任务
 * 一份数据
 * 
 * 生产任务与消费任务共用一个数据--产品类
 * 
 * 要求:最终也要实现一次生产一次消费
 * 
 *错误描述:当有两个生产线程,两个消费线程同时存在的时候,有可能出现生产一次,消费多次或者生产多次消费一次的情况.
 *原因:当线程被重新唤醒之后,没有判断标记,直接执行了下面的代码
 *
 *解决办法:将标记处的if改成while
 *
 *问题描述:继续运行程序,会出现死锁的情况(4个线程同时处于等待状态)
 *原因:唤醒的是本方的线程,最后导致所有的线程都处于等待状态.
 *
 *解决办法:将notify改成notifyAll.保证将对方的线程唤醒
 *
 *死锁:出现的情况有两种
 *1.所有的线程处于等待状态
 *2.锁之间进行嵌套调用
 *
 */
public class Demo5 {
	public static void main(String[] args) {
		//1.准备数据
		Product1 product = new Product1();
		//2.创建生产消费任务
		Producer1 producer = new Producer1(product);
		Consumer1 consumer = new Consumer1(product);
		//3.创建生产消费线程
		Thread thread0 = new Thread(producer);
		Thread thread1 = new Thread(producer);
		Thread thread2 = new Thread(consumer);
		Thread thread3 = new Thread(consumer);
		//4.开启线程
		thread0.start();
		thread1.start();
		thread2.start();
		thread3.start();
	}
}

//数据类
class Product1{
	String name;
	double price;
	int count;
	
	//标识
	boolean flag;
	
	//准备生产
	public synchronized void setProduce(String name,double price) {
		while (flag == true) {
			try {
				wait();
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		
		this.name = name;
		this.price = price;
		
		System.out.println(Thread.currentThread().getName()+"  生产了:"+name+"  产品的数量:"+count+"  产品的价格:"+price);
		
		count++;
		
		flag = !flag;
		
		//唤醒消费线程
		//notify();
		notifyAll();
	}
	//准备消费
	public synchronized void consume() {
		while (flag == false) {
			try {
				wait();
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		
		System.out.println(Thread.currentThread().getName()+"  消费了:"+name+"  产品的数量:"+count+"  产品的价格:"+price);
		
		flag = !flag;
		
		//唤醒生产线程
		//notify();
		notifyAll();
	}
}
//生产任务
class Producer1 implements Runnable{
	Product1 product;

	public Producer1(Product1 product) {
		super();
		this.product = product;
	}
	
	public void run() {
		while (true) {
			product.setProduce("bingbing", 10);
		}
	}
}
//消费任务
class Consumer1 implements Runnable{
	Product1 product;

	public Consumer1(Product1 product) {
		super();
		this.product = product;
	}
	
	public void run() {
		while (true) {
			product.consume();
		}
	}
}
```
# lock锁
> 使用lock锁和condition的await,signal方法

```
package com.qianfeng.test;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/*
 * wait,notify,notifyall必须是在同步的前提下才能使用
 * 
 * 
 * 研究:研究Lock
 * 比较synchronized和Lock
 * 1.synchronized:从jdk1.0就开始使用的同步方法-称为隐式同步
 * 	synchronized(锁对象){//获取锁      我们将锁还可以称为锁旗舰或者监听器
 * 		同步的代码
 * }//释放锁
 * 2.Lock:从jdk1.5开始使用的同步方法-称为显示同步
 * 
 * 原理:Lock本身是接口,要通过他的子类创建对象干活儿
 *  使用过程:
 *  首先调用lock()方法获取锁
 *    进行同步的代码块儿
 *  使用unlock()方法释放锁
 *  
 *  使用的场景:
 *  当进行多生产者多消费者的功能时,使用Lock,其他的都使用synchronized
 *  
 *  使用效率上:Lock高于synchronized
 */
public class Demo6 {
	public static void main(String[] args) {
		//1.准备数据
		Product2 product = new Product2();
		//2.创建生产消费任务
		Producer2 producer = new Producer2(product);
		Consumer2 consumer = new Consumer2(product);
		//3.创建生产消费线程
		Thread thread0 = new Thread(producer);
		Thread thread1 = new Thread(producer);
		Thread thread2 = new Thread(consumer);
		Thread thread3 = new Thread(consumer);
		//4.开启线程
		thread0.start();
		thread1.start();
		thread2.start();
		thread3.start();
	}
}

//数据类
class Product2{
	String name;
	double price;
	int count;
	
	//标识
	boolean flag;
	
	//创建锁对象
	Lock lock = new ReentrantLock();
	
	//获取为生产任务提高唤醒等待的Condition对象
	Condition conditionPro = lock.newCondition();
	//获取为消费任务提高唤醒等待的Condition对象
	Condition conditionCon = lock.newCondition();
	
	//准备生产
	public  void setProduce(String name,double price) {
		try {
			lock.lock();//获取锁
			while (flag == true) {
				try {
					conditionPro.await();//让生产线程等待
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
			
			this.name = name;
			this.price = price;
			
			System.out.println(Thread.currentThread().getName()+"  生产了:"+name+"  产品的数量:"+count+"  产品的价格:"+price);
			
			count++;
			
			flag = !flag;
			
			//唤醒消费线程
			//notify();
			//notifyAll();
			conditionCon.signal();
		
		} finally {//放的是必须执行的代码,用于资源的释放
			lock.unlock();//释放
		}
		
	}
	//准备消费
	public  void consume() {
		try {
			lock.lock();
			while (flag == false) {
				try {
					//wait();
					conditionCon.await();
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
			
			System.out.println(Thread.currentThread().getName()+"  消费了:"+name+"  产品的数量:"+count+"  产品的价格:"+price);
			
			flag = !flag;
			
			//唤醒生产线程
			//notify();
			//notifyAll();
			conditionPro.signal();
		} finally {
			lock.unlock();
		}
	}
}
//生产任务
class Producer2 implements Runnable{
	Product2 product;

	public Producer2(Product2 product) {
		super();
		this.product = product;
	}
	
	public void run() {
		while (true) {
			product.setProduce("bingbing", 10);
		}
	}
}
//消费任务

class Consumer2 implements Runnable{
	Product2 product;

	public Consumer2(Product2 product) {
		super();
		this.product = product;
	}
	
	public void run() {
		while (true) {
			product.consume();
		}
	}
}

```

# 线程的停止

**想要线程停止:**
1. 通过一个标识结束线程
2. ~~调用stop方法~~(弃用了)
3. 调用interrupt()方法