---
layout:     post
title:      "java基础之多线程,线程安全"
subtitle:   "java基础之多线程,线程安全"
date:       2018-08-14 12:00:00
author:     "Chamber"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - java
    - 多线程
    - Java基础
    - 数据类型
---
# 线程

> 默认情况下,JVM有主线程和垃圾回收线程,但是他们都是由系统创建的,为了完成我们自己的任务,要创建自己的线程,
>
> Java将程序面向对象了,形成的类就是Thread类,在thread类内部完成工作的任务区就是run方法.

- **注意:**
如果想让run作为任务区,必须通过执行start方法,让run自动执行,不能手动调用

# 两种创建线程的方式

## 通过实现 Runnable 接口来创建线程

> 如果我们自己创建了独立的任务类.线程会优先调用我们手动传入的任务类对象的run方法,不会再去调用thread类默认的run方法

> 任务独立开来,让线程和任务分离,好处:那个线程工作,就将拿个线程交给谁,操作方便

创建一个线程，最简单的方法是创建一个实现 Runnable 接口的类。

为了实现 Runnable，一个类只需要执行一个方法调用 run()，声明如下：

```
public void run()
```

你可以重写该方法，重要的是理解的 run() 可以调用其他方法，使用其他类，并声明变量，就像主线程一样。

在创建一个实现 Runnable 接口的类之后，你可以在类中实例化一个线程对象。

Thread 定义了几个构造方法，下面的这个是我们经常使用的：

```
Thread(Runnable threadOb,String threadName);
```

这里，threadOb 是一个实现 Runnable 接口的类的实例，并且 threadName 指定新线程的名字。

新线程创建之后，你调用它的 start() 方法它才会运行。

```
void start();
```

## 通过继承Thread来创建线程

> 让run留在了线程类的内部,操作不方便

创建一个线程的第二种方法是创建一个新的类，该类继承 Thread 类，然后创建一个该类的实例。

继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行。

该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例。


# 线程安全问题:

### 线程为什么会不安全?-->

1. **原子性:** 

一个操作（有可能包含有多个子操作）要么全部执行（生效），要么全部都不执行（都不生效）。
2. **可见性:**

可见性是指，当多个线程并发访问共享变量时，一个线程对共享变量的修改，其它线程能够立即看到。可见性问题是好多人忽略或者理解错误的一点。

CPU从主内存中读数据的效率相对来说不高，现在主流的计算机中，都有几级缓存。每个线程读取共享变量时，都会将该变量加载进其对应CPU的高速缓存里，修改该变量后，CPU会立即更新该缓存，但并不一定会立即将其写回主内存（实际上写回主内存的时间不可预期）。此时其它线程（尤其是不在同一个CPU上执行的线程）访问该变量时，从主内存中读到的就是旧的数据，而非第一个线程更新后的数据。

这一点是操作系统或者说是硬件层面的机制，所以很多应用开发人员经常会忽略。

3. **顺序性:**

顺序性指的是，程序执行的顺序按照代码的先后顺序执行。

# 线程锁:

>  在代码中使用同步代码块儿(同步锁)
 解释:在某一段任务中,同一时间只允许一个线程执行任务,其他的线程即使抢到了cpu,也无法进入当前的任务区间,只有当当前的线程将任务执行完后,
 其他的线程才能有资格进入
 
  同步代码块儿的构成:
 ```
 synchronized(锁(对象)){
 	  同步的代码
 }
 ```
 
- **对作为锁的对象的要求:**
1. ==必须是对象==      
2. ==必须保证被多个线程共享==

- **可以充当锁的:**
1. 一个普通的对象      
2. 当前对象的引用--this    
3. 类的字节码文件

- **同步代码块儿的特点:**
1. 可以保证线程的安全     
2. 由于每次都要进行判断处理,所以降低了执行效率

- **什么时候使用同步代码块儿:**
 1. 多个线程共享一个数据
 2. 至少有两个线程
 

# 理解synchronized关键字
### synchronized关键字的作用域有二种： 
1. 是某个对象实例内，```synchronized aMethod(){}```可以防止多个线程同时访问这个对象
的```synchronized```方法（如果一个对象有多个```synchronized```方法，只要一个线程访问了其中的
一个```synchronized```方法，其它线程不能同时访问这个对象中任何一个```synchronized```方法）。
这时，不同的对象实例的```synchronized```方法是不相干扰的。也就是说，其它线程照样可以同时
访问相同类的另一个对象实例中的```synchronized```方法； 
2. 是某个类的范围，```synchronized static aStaticMethod{}```防止多个线程同时访问
这个类中的```synchronized static ```方法。它可以对类的所有对象实例起作用。

### 除了方法前用synchronized关键字，synchronized关键字还可以用于方法中的某个区块中，
表示只对这个区块的资源实行互斥访问。用法是: synchronized(this){/区块/}，它的作用域是当前对象；

### synchronized关键字是不能继承的，也就是说，基类的方法synchronized f(){} 
在继承类中并不自动是```synchronized f(){}```，而是变成了```f(){}```。继承类需要你显式的指定
它的某个方法为synchronized方法；

# 线程锁在单例模式中的使用

> 在恶汉式中不需要使用线程锁,因为恶汉式只有一行代码,不会发生线程安全问题

```

//饿汉式
class SingleInstance {
	private final static SingleInstance singleInstance = new SingleInstance();
	
	private SingleInstance(){
		
	}
	
	public static SingleInstance getInstance(){
		return singleInstance;//这里只有一行代码,所以不会发生线程安全问题
	}
}

//懒汉式
class SingleInstance1 {
	private static SingleInstance1 singleInstance = null;
	
	private SingleInstance1(){
		
	}
	
	public static SingleInstance1 getInstance(){
		if (singleInstance == null) {//写他的目的:尽量减少线程安全代码的判断次数,提高效率
			
			synchronized (SingleInstance1.class) {
				if (singleInstance == null) {
					singleInstance = new SingleInstance1();
				}
			}
			
		}
		return singleInstance;
	}
}
```
